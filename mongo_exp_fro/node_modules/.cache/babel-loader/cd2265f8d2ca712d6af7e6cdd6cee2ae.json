{"ast":null,"code":"import '../../../../utils/index.mjs';\nimport createGrid from '../builders/build-grid.mjs';\nimport { AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, SMART_ALIGNMENT } from '../defaults.mjs';\nimport { isNumber } from '@vueuse/core';\nimport { throwError } from '../../../../utils/error.mjs';\nconst SCOPE = \"ElFixedSizeGrid\";\nconst FixedSizeGrid = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: ({\n    columnWidth\n  }, index) => [columnWidth, index * columnWidth],\n  getRowPosition: ({\n    rowHeight\n  }, index) => [rowHeight, index * rowHeight],\n  getEstimatedTotalHeight: ({\n    totalRow,\n    rowHeight\n  }) => rowHeight * totalRow,\n  getEstimatedTotalWidth: ({\n    totalColumn,\n    columnWidth\n  }) => columnWidth * totalColumn,\n  getColumnOffset: ({\n    totalColumn,\n    columnWidth,\n    width\n  }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {\n    width = Number(width);\n    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n\n      case END_ALIGNMENT:\n        return minOffset;\n\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(width / 2)) {\n            return 0;\n          } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n            return lastColumnOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getRowOffset: ({\n    rowHeight,\n    height,\n    totalRow\n  }, rowIndex, align, scrollTop, _, scrollBarWidth) => {\n    height = Number(height);\n    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n\n      case END_ALIGNMENT:\n        return minOffset;\n\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(height / 2)) {\n            return 0;\n          } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n            return lastRowOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: ({\n    columnWidth,\n    totalColumn\n  }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),\n  getColumnStopIndexForStartIndex: ({\n    columnWidth,\n    totalColumn,\n    width\n  }, startIndex, scrollLeft) => {\n    const left = startIndex * columnWidth;\n    const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: ({\n    rowHeight,\n    totalRow\n  }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),\n  getRowStopIndexForStartIndex: ({\n    rowHeight,\n    totalRow,\n    height\n  }, startIndex, scrollTop) => {\n    const top = startIndex * rowHeight;\n    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: () => void 0,\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nexport { FixedSizeGrid as default };","map":{"version":3,"mappings":"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","names":["SCOPE","FixedSizeGrid","createGrid","name","getColumnPosition","columnWidth","index","getRowPosition","rowHeight","getEstimatedTotalHeight","totalRow","getEstimatedTotalWidth","totalColumn","getColumnOffset","width","columnIndex","alignment","scrollLeft","_","scrollBarWidth","Number","lastColumnOffset","Math","max","maxOffset","min","minOffset","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","middleOffset","round","ceil","floor","getRowOffset","height","rowIndex","align","scrollTop","lastRowOffset","SMART_ALIGNMENT","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","startIndex","left","visibleColumnsCount","getRowStartIndexForOffset","getRowStopIndexForStartIndex","top","numVisibleRows","initCache","clearCache","validateProps","process","env","NODE_ENV","isNumber","throwError"],"sources":["../../../../../../../packages/components/virtual-list/src/components/fixed-size-grid.ts"],"sourcesContent":["import { isNumber, throwError } from '@element-plus/utils'\nimport createGrid from '../builders/build-grid'\n\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\n\nconst SCOPE = 'ElFixedSizeGrid'\n\nconst FixedSizeGrid = createGrid({\n  name: 'ElFixedSizeGrid',\n  getColumnPosition: ({ columnWidth }, index) => [\n    columnWidth as number,\n    index * (columnWidth as number),\n  ],\n\n  getRowPosition: ({ rowHeight }, index) => [\n    rowHeight as number,\n    index * (rowHeight as number),\n  ],\n\n  getEstimatedTotalHeight: ({ totalRow, rowHeight }) =>\n    (rowHeight as number) * totalRow,\n\n  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) =>\n    (columnWidth as number) * totalColumn,\n\n  getColumnOffset: (\n    { totalColumn, columnWidth, width },\n    columnIndex,\n    alignment,\n    scrollLeft,\n    _,\n    scrollBarWidth\n  ) => {\n    width = Number(width)\n    const lastColumnOffset = Math.max(\n      0,\n      totalColumn * (columnWidth as number) - width\n    )\n    const maxOffset = Math.min(\n      lastColumnOffset,\n      columnIndex * (columnWidth as number)\n    )\n    const minOffset = Math.max(\n      0,\n      columnIndex * (columnWidth as number) -\n        width +\n        scrollBarWidth +\n        (columnWidth as number)\n    )\n\n    if (alignment === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset\n      case END_ALIGNMENT:\n        return minOffset\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft\n        } else if (minOffset > maxOffset) {\n          return minOffset\n        } else if (scrollLeft < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n    }\n  },\n\n  getRowOffset: (\n    { rowHeight, height, totalRow },\n    rowIndex,\n    align,\n    scrollTop,\n    _,\n    scrollBarWidth\n  ): number => {\n    height = Number(height)\n    const lastRowOffset = Math.max(0, totalRow * (rowHeight as number) - height)\n    const maxOffset = Math.min(lastRowOffset, rowIndex * (rowHeight as number))\n    const minOffset = Math.max(\n      0,\n      rowIndex * (rowHeight as number) -\n        height +\n        scrollBarWidth +\n        (rowHeight as number)\n    )\n\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT\n      } else {\n        align = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset\n      case END_ALIGNMENT:\n        return minOffset\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop\n        } else if (minOffset > maxOffset) {\n          return minOffset\n        } else if (scrollTop < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n    }\n  },\n\n  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) =>\n    Math.max(\n      0,\n      Math.min(\n        totalColumn - 1,\n        Math.floor(scrollLeft / (columnWidth as number))\n      )\n    ),\n\n  getColumnStopIndexForStartIndex: (\n    { columnWidth, totalColumn, width },\n    startIndex: number,\n    scrollLeft: number\n  ): number => {\n    const left = startIndex * (columnWidth as number)\n    const visibleColumnsCount = Math.ceil(\n      ((width as number) + scrollLeft - left) / (columnWidth as number)\n    )\n    return Math.max(\n      0,\n      Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1)\n    )\n  },\n\n  getRowStartIndexForOffset: (\n    { rowHeight, totalRow },\n    scrollTop: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(totalRow - 1, Math.floor(scrollTop / (rowHeight as number)))\n    ),\n\n  getRowStopIndexForStartIndex: (\n    { rowHeight, totalRow, height },\n    startIndex: number,\n    scrollTop: number\n  ): number => {\n    const top = startIndex * (rowHeight as number)\n    const numVisibleRows = Math.ceil(\n      ((height as number) + scrollTop - top) / (rowHeight as number)\n    )\n    return Math.max(\n      0,\n      Math.min(\n        totalRow - 1,\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n      )\n    )\n  },\n  /**\n   * Fixed size grid does not need this cache\n   * Using any to bypass it, TODO: Using type inference to fix this.\n   */\n  initCache: () => undefined as any,\n\n  clearCache: true,\n\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isNumber(columnWidth)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `\n        )\n      }\n\n      if (!isNumber(rowHeight)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default FixedSizeGrid\n"]},"metadata":{},"sourceType":"module"}