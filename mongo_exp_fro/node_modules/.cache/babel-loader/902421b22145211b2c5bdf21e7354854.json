{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { defineComponent, computed, ref, reactive, unref, watch, onBeforeUnmount, h, withModifiers } from 'vue';\nimport '../../../scrollbar/index.mjs';\nimport '../../../../utils/index.mjs';\nimport '../../../../hooks/index.mjs';\nimport { HORIZONTAL, ScrollbarDirKey, SCROLLBAR_MIN_SIZE } from '../defaults.mjs';\nimport { virtualizedScrollbarProps } from '../props.mjs';\nimport { renderThumbStyle } from '../utils.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { BAR_MAP } from '../../../scrollbar/src/util.mjs';\nimport { cAF, rAF } from '../../../../utils/raf.mjs';\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: virtualizedScrollbarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n\n  setup(props, {\n    emit\n  }) {\n    const GAP = computed(() => props.startGap + props.endGap);\n    const nsVirtualScrollbar = useNamespace(\"virtual-scrollbar\");\n    const nsScrollbar = useNamespace(\"scrollbar\");\n    const trackRef = ref();\n    const thumbRef = ref();\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackSize = computed(() => props.clientSize - unref(GAP));\n    const trackStyle = computed(() => ({\n      position: \"absolute\",\n      width: `${HORIZONTAL === props.layout ? trackSize.value : props.scrollbarSize}px`,\n      height: `${HORIZONTAL === props.layout ? props.scrollbarSize : trackSize.value}px`,\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }));\n    const thumbSize = computed(() => {\n      const ratio = props.ratio;\n      const clientSize = props.clientSize;\n\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (ratio >= 50) {\n        return ratio * clientSize / 100;\n      }\n\n      const SCROLLBAR_MAX_SIZE = clientSize / 3;\n      return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - unref(GAP)));\n\n    const attachEvents = () => {\n      window.addEventListener(\"mousemove\", onMouseMove);\n      window.addEventListener(\"mouseup\", onMouseUp);\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      onselectstartStore = document.onselectstart;\n\n      document.onselectstart = () => false;\n\n      thumbEl.addEventListener(\"touchmove\", onMouseMove);\n      thumbEl.addEventListener(\"touchend\", onMouseUp);\n    };\n\n    const detachEvents = () => {\n      window.removeEventListener(\"mousemove\", onMouseMove);\n      window.removeEventListener(\"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      thumbEl.removeEventListener(\"touchmove\", onMouseMove);\n      thumbEl.removeEventListener(\"touchend\", onMouseUp);\n    };\n\n    const onThumbMouseDown = e => {\n      e.stopImmediatePropagation();\n\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n\n    const onMouseMove = e => {\n      const {\n        isDragging\n      } = state;\n      if (!isDragging) return;\n      if (!thumbRef.value || !trackRef.value) return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage) return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(props.startGap, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n\n    const clickTrackHandler = e => {\n      const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);\n      const thumbHalf = thumbRef.value[bar.value.offset] / 2;\n      const distance = offset - thumbHalf;\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n      emit(\"scroll\", distance, totalSteps.value);\n    };\n\n    watch(() => props.scrollFrom, v => {\n      if (state.isDragging) return;\n      state.traveled = Math.ceil(v * totalSteps.value);\n    });\n    onBeforeUnmount(() => {\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: [nsVirtualScrollbar.b(), props.class, (props.alwaysOn || state.isDragging) && \"always-on\"],\n        style: trackStyle.value,\n        onMousedown: withModifiers(clickTrackHandler, [\"stop\", \"prevent\"]),\n        onTouchstartPrevent: onThumbMouseDown\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: nsScrollbar.e(\"thumb\"),\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, []));\n    };\n  }\n\n});\nexport { ScrollBar as default };","map":{"version":3,"mappings":"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","names":["ScrollBar","defineComponent","name","props","virtualizedScrollbarProps","emits","setup","emit","GAP","computed","startGap","endGap","nsVirtualScrollbar","useNamespace","nsScrollbar","trackRef","ref","thumbRef","frameHandle","onselectstartStore","state","reactive","isDragging","traveled","bar","BAR_MAP","layout","trackSize","clientSize","unref","trackStyle","position","width","HORIZONTAL","value","scrollbarSize","height","ScrollbarDirKey","right","bottom","borderRadius","thumbSize","ratio","Number","POSITIVE_INFINITY","SCROLLBAR_MAX_SIZE","Math","floor","min","max","SCROLLBAR_MIN_SIZE","thumbStyle","isFinite","display","thumb","style","renderThumbStyle","size","move","totalSteps","attachEvents","window","addEventListener","onMouseMove","onMouseUp","thumbEl","document","onselectstart","detachEvents","removeEventListener","onThumbMouseDown","e","stopImmediatePropagation","ctrlKey","includes","button","axis","currentTarget","offset","client","getBoundingClientRect","direction","prevPage","cAF","thumbClickPosition","distance","rAF","clickTrackHandler","abs","target","thumbHalf","watch","scrollFrom","v","ceil","onBeforeUnmount","h","role","class","b","alwaysOn","onMousedown","withModifiers","onTouchstartPrevent"],"sources":["../../../../../../../packages/components/virtual-list/src/components/scrollbar.ts"],"sourcesContent":["// @ts-nocheck\nimport {\n  computed,\n  defineComponent,\n  h,\n  onBeforeUnmount,\n  reactive,\n  ref,\n  unref,\n  watch,\n  withModifiers,\n} from 'vue'\nimport { BAR_MAP } from '@element-plus/components/scrollbar'\nimport { cAF, rAF } from '@element-plus/utils'\n\nimport { useNamespace } from '@element-plus/hooks'\nimport { HORIZONTAL, SCROLLBAR_MIN_SIZE, ScrollbarDirKey } from '../defaults'\nimport { virtualizedScrollbarProps } from '../props'\nimport { renderThumbStyle } from '../utils'\n\nimport type { CSSProperties } from 'vue'\n\nconst ScrollBar = defineComponent({\n  name: 'ElVirtualScrollBar',\n  props: virtualizedScrollbarProps,\n  emits: ['scroll', 'start-move', 'stop-move'],\n  setup(props, { emit }) {\n    const GAP = computed(() => props.startGap + props.endGap) // top 2 + bottom 2 | left 2 + right 2\n\n    const nsVirtualScrollbar = useNamespace('virtual-scrollbar')\n    const nsScrollbar = useNamespace('scrollbar')\n    // DOM refs\n    const trackRef = ref<HTMLElement>()\n    const thumbRef = ref<HTMLElement>()\n\n    // local variables\n    let frameHandle: null | number = null\n    let onselectstartStore: null | typeof document.onselectstart = null\n\n    // data\n    const state = reactive({\n      isDragging: false,\n      traveled: 0,\n    })\n\n    const bar = computed(() => BAR_MAP[props.layout])\n\n    const trackSize = computed(() => props.clientSize! - unref(GAP))\n\n    const trackStyle = computed<CSSProperties>(() => ({\n      position: 'absolute',\n      width: `${\n        HORIZONTAL === props.layout ? trackSize.value : props.scrollbarSize\n      }px`,\n      height: `${\n        HORIZONTAL === props.layout ? props.scrollbarSize : trackSize.value\n      }px`,\n      [ScrollbarDirKey[props.layout]]: '2px',\n      right: '2px',\n      bottom: '2px',\n      borderRadius: '4px',\n    }))\n\n    const thumbSize = computed(() => {\n      const ratio = props.ratio!\n      const clientSize = props.clientSize!\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY\n      }\n\n      if (ratio >= 50) {\n        return (ratio * clientSize) / 100\n      }\n\n      const SCROLLBAR_MAX_SIZE = clientSize / 3\n      return Math.floor(\n        Math.min(\n          Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE),\n          SCROLLBAR_MAX_SIZE\n        )\n      )\n    })\n\n    // const sizeRange = computed(() => props.size - thumbSize.value)\n\n    const thumbStyle = computed<CSSProperties>(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: 'none',\n        }\n      }\n\n      const thumb = `${thumbSize.value}px`\n\n      const style: CSSProperties = renderThumbStyle(\n        {\n          bar: bar.value,\n          size: thumb,\n          move: state.traveled,\n        },\n        props.layout\n      )\n\n      return style\n    })\n\n    const totalSteps = computed(() =>\n      Math.floor(props.clientSize! - thumbSize.value - unref(GAP))\n    )\n\n    const attachEvents = () => {\n      window.addEventListener('mousemove', onMouseMove)\n      window.addEventListener('mouseup', onMouseUp)\n\n      const thumbEl = unref(thumbRef)\n\n      if (!thumbEl) return\n\n      onselectstartStore = document.onselectstart\n      document.onselectstart = () => false\n\n      thumbEl.addEventListener('touchmove', onMouseMove)\n      thumbEl.addEventListener('touchend', onMouseUp)\n    }\n\n    const detachEvents = () => {\n      window.removeEventListener('mousemove', onMouseMove)\n      window.removeEventListener('mouseup', onMouseUp)\n\n      document.onselectstart = onselectstartStore\n      onselectstartStore = null\n\n      const thumbEl = unref(thumbRef)\n      if (!thumbEl) return\n\n      thumbEl.removeEventListener('touchmove', onMouseMove)\n      thumbEl.removeEventListener('touchend', onMouseUp)\n    }\n\n    const onThumbMouseDown = (e: Event) => {\n      e.stopImmediatePropagation()\n      if (\n        (e as KeyboardEvent).ctrlKey ||\n        [1, 2].includes((e as MouseEvent).button)\n      ) {\n        return\n      }\n\n      state.isDragging = true\n      state[bar.value.axis] =\n        e.currentTarget![bar.value.offset] -\n        (e[bar.value.client] -\n          (e.currentTarget as HTMLElement).getBoundingClientRect()[\n            bar.value.direction\n          ])\n\n      emit('start-move')\n      attachEvents()\n    }\n\n    const onMouseUp = () => {\n      state.isDragging = false\n      state[bar.value.axis] = 0\n      emit('stop-move')\n      detachEvents()\n    }\n\n    const onMouseMove = (e: Event) => {\n      const { isDragging } = state\n      if (!isDragging) return\n      if (!thumbRef.value || !trackRef.value) return\n\n      const prevPage = state[bar.value.axis]\n      if (!prevPage) return\n\n      cAF(frameHandle!)\n      // using the current track's offset top/left - the current pointer's clientY/clientX\n      // to get the relative position of the pointer to the track.\n      const offset =\n        (trackRef.value.getBoundingClientRect()[bar.value.direction] -\n          e[bar.value.client]) *\n        -1\n\n      // find where the thumb was clicked on.\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage\n      /**\n       *  +--------------+                                   +--------------+\n       *  |              -  <--------- thumb.offsetTop       |              |\n       *  |             |+|             <--+                 |              |\n       *  |              -                 |                 |              |\n       *  |   Content    |                 |                 |              |\n       *  |              |                 |                 |              |\n       *  |              |                 |                 |              |\n       *  |              |                 |                 |              -\n       *  |              |                 +-->              |             |+|\n       *  |              |                                   |              -\n       *  +--------------+                                   +--------------+\n       */\n\n      // using the current position - prev position to\n\n      const distance = offset - thumbClickPosition\n      // get how many steps in total.\n      // gap of 2 on top, 2 on bottom, in total 4.\n      // using totalSteps รท totalSize getting each step's size * distance to get the new\n      // scroll offset to scrollTo\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(\n          props.startGap,\n          Math.min(\n            distance,\n            totalSteps.value // 2 is the top value\n          )\n        )\n        emit('scroll', distance, totalSteps.value)\n      })\n    }\n\n    const clickTrackHandler = (e: MouseEvent) => {\n      const offset = Math.abs(\n        (e.target as HTMLElement).getBoundingClientRect()[bar.value.direction] -\n          e[bar.value.client]\n      )\n      const thumbHalf = thumbRef.value![bar.value.offset] / 2\n      const distance = offset - thumbHalf\n\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value))\n      emit('scroll', distance, totalSteps.value)\n    }\n\n    watch(\n      () => props.scrollFrom,\n      (v) => {\n        if (state.isDragging) return\n        /**\n         *  this is simply mapping the current scrollbar offset\n         *\n         *  formula 1:\n         *    v = scrollOffset / (estimatedTotalSize - clientSize)\n         *    traveled = v * (clientSize - thumbSize - GAP) --> v * totalSteps\n         *\n         *  formula 2:\n         *    traveled = (v * clientSize) / (clientSize / totalSteps) --> (v * clientSize) * (totalSteps / clientSize) --> v * totalSteps\n         */\n        state.traveled = Math.ceil(v! * totalSteps.value)\n      }\n    )\n\n    onBeforeUnmount(() => {\n      detachEvents()\n    })\n\n    return () => {\n      return h(\n        'div',\n        {\n          role: 'presentation',\n          ref: trackRef,\n          class: [\n            nsVirtualScrollbar.b(),\n            props.class,\n            (props.alwaysOn || state.isDragging) && 'always-on',\n          ],\n          style: trackStyle.value,\n          onMousedown: withModifiers(clickTrackHandler, ['stop', 'prevent']),\n          onTouchstartPrevent: onThumbMouseDown,\n        },\n        h(\n          'div',\n          {\n            ref: thumbRef,\n            class: nsScrollbar.e('thumb'),\n            style: thumbStyle.value,\n            onMousedown: onThumbMouseDown,\n          },\n          []\n        )\n      )\n    }\n  },\n})\n\nexport default ScrollBar\n"]},"metadata":{},"sourceType":"module"}