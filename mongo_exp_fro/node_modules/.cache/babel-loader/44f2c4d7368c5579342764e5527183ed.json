{"ast":null,"code":"function isValidValue(val) {\n  return val || val === 0;\n}\n\nfunction isValidArray(val) {\n  return Array.isArray(val) && val.length;\n}\n\nfunction toValidArray(val) {\n  return Array.isArray(val) ? val : isValidValue(val) ? [val] : [];\n}\n\nfunction treeFind(treeData, findCallback, getChildren, resultCallback, parent) {\n  for (let i = 0; i < treeData.length; i++) {\n    const data = treeData[i];\n\n    if (findCallback(data, i, treeData, parent)) {\n      return resultCallback ? resultCallback(data, i, treeData, parent) : data;\n    } else {\n      const children = getChildren(data);\n\n      if (isValidArray(children)) {\n        const find = treeFind(children, findCallback, getChildren, resultCallback, data);\n        if (find) return find;\n      }\n    }\n  }\n}\n\nexport { isValidArray, isValidValue, toValidArray, treeFind };","map":{"version":3,"mappings":"AAAO,SAASA,YAAT,CAAsBC,GAAtB,EAA2B;EAChC,OAAOA,GAAG,IAAIA,GAAG,KAAK,CAAtB;AACD;;AACM,SAASC,YAAT,CAAsBD,GAAtB,EAA2B;EAChC,OAAOE,KAAK,CAACC,OAAN,CAAcH,GAAd,KAAsBA,GAAG,CAACI,MAAjC;AACD;;AACM,SAASC,YAAT,CAAsBL,GAAtB,EAA2B;EAChC,OAAOE,KAAK,CAACC,OAAN,CAAcH,GAAd,IAAqBA,GAArB,GAA2BD,YAAY,CAACC,GAAD,CAAZ,GAAoB,CAACA,GAAD,CAApB,GAA4B,EAA9D;AACD;;AACM,SAASM,QAAT,CAAkBC,QAAlB,EAA4BC,YAA5B,EAA0CC,WAA1C,EAAuDC,cAAvD,EAAuEC,MAAvE,EAA+E;EACpF,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,QAAQ,CAACH,MAA7B,EAAqCQ,CAAC,EAAtC,EAA0C;IACxC,MAAMC,IAAI,GAAGN,QAAQ,CAACK,CAAD,CAArB;;IACA,IAAIJ,YAAY,CAACK,IAAD,EAAOD,CAAP,EAAUL,QAAV,EAAoBI,MAApB,CAAhB,EAA6C;MAC3C,OAAOD,cAAc,GAAGA,cAAc,CAACG,IAAD,EAAOD,CAAP,EAAUL,QAAV,EAAoBI,MAApB,CAAjB,GAA+CE,IAApE;IACD,CAFD,MAEO;MACL,MAAMC,QAAQ,GAAGL,WAAW,CAACI,IAAD,CAA5B;;MACA,IAAIZ,YAAY,CAACa,QAAD,CAAhB,EAA4B;QAC1B,MAAMC,IAAI,GAAGT,QAAQ,CAACQ,QAAD,EAAWN,YAAX,EAAyBC,WAAzB,EAAsCC,cAAtC,EAAsDG,IAAtD,CAArB;QACA,IAAIE,IAAJ,EACE,OAAOA,IAAP;MACH;IACF;EACF;AACH","names":["isValidValue","val","isValidArray","Array","isArray","length","toValidArray","treeFind","treeData","findCallback","getChildren","resultCallback","parent","i","data","children","find"],"sources":["../../../../../../packages/components/tree-select/src/utils.ts"],"sourcesContent":["import type { TreeNodeData } from '@element-plus/components/tree/src/tree.type'\n\nexport function isValidValue(val: any) {\n  return val || val === 0\n}\n\nexport function isValidArray(val: any) {\n  return Array.isArray(val) && val.length\n}\n\nexport function toValidArray(val: any) {\n  return Array.isArray(val) ? val : isValidValue(val) ? [val] : []\n}\n\ntype TreeCallback<T extends TreeNodeData, R> = (\n  data: T,\n  index: number,\n  array: T[],\n  parent?: T\n) => R\n\ntype TreeFindCallback<T extends TreeNodeData> = TreeCallback<T, boolean>\n\nexport function treeFind<T extends TreeNodeData>(\n  treeData: T[],\n  findCallback: TreeFindCallback<T>,\n  getChildren: (data: T) => T[]\n): T | undefined\nexport function treeFind<T extends TreeNodeData, R>(\n  treeData: T[],\n  findCallback: TreeFindCallback<T>,\n  getChildren: (data: T) => T[],\n  resultCallback?: TreeCallback<T, R>,\n  parent?: T\n): R | undefined\nexport function treeFind<T extends TreeNodeData, R>(\n  treeData: T[],\n  findCallback: TreeFindCallback<T>,\n  getChildren: (data: T) => T[],\n  resultCallback?: TreeCallback<T, R>,\n  parent?: T\n): T | R | undefined {\n  for (let i = 0; i < treeData.length; i++) {\n    const data = treeData[i]\n    if (findCallback(data, i, treeData, parent)) {\n      return resultCallback ? resultCallback(data, i, treeData, parent) : data\n    } else {\n      const children = getChildren(data)\n      if (isValidArray(children)) {\n        const find = treeFind(\n          children,\n          findCallback,\n          getChildren,\n          resultCallback,\n          data\n        )\n        if (find) return find\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}