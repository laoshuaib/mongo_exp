{"ast":null,"code":"import { isFunction, capitalize } from '@vue/shared';\nimport '../../../utils/index.mjs';\nimport { isEmpty, isUndefined } from '../../../utils/types.mjs';\n\nvar ExpandTrigger = /* @__PURE__ */(ExpandTrigger2 => {\n  ExpandTrigger2[\"CLICK\"] = \"click\";\n  ExpandTrigger2[\"HOVER\"] = \"hover\";\n  return ExpandTrigger2;\n})(ExpandTrigger || {});\n\nlet uid = 0;\n\nconst calculatePathNodes = node => {\n  const nodes = [node];\n  let {\n    parent\n  } = node;\n\n  while (parent) {\n    nodes.unshift(parent);\n    parent = parent.parent;\n  }\n\n  return nodes;\n};\n\nclass Node {\n  constructor(data, config, parent, root = false) {\n    this.data = data;\n    this.config = config;\n    this.parent = parent;\n    this.root = root;\n    this.uid = uid++;\n    this.checked = false;\n    this.indeterminate = false;\n    this.loading = false;\n    const {\n      value: valueKey,\n      label: labelKey,\n      children: childrenKey\n    } = config;\n    const childrenData = data[childrenKey];\n    const pathNodes = calculatePathNodes(this);\n    this.level = root ? 0 : parent ? parent.level + 1 : 1;\n    this.value = data[valueKey];\n    this.label = data[labelKey];\n    this.pathNodes = pathNodes;\n    this.pathValues = pathNodes.map(node => node.value);\n    this.pathLabels = pathNodes.map(node => node.label);\n    this.childrenData = childrenData;\n    this.children = (childrenData || []).map(child => new Node(child, config, this));\n    this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData);\n  }\n\n  get isDisabled() {\n    const {\n      data,\n      parent,\n      config\n    } = this;\n    const {\n      disabled,\n      checkStrictly\n    } = config;\n    const isDisabled = isFunction(disabled) ? disabled(data, this) : !!data[disabled];\n    return isDisabled || !checkStrictly && (parent == null ? void 0 : parent.isDisabled);\n  }\n\n  get isLeaf() {\n    const {\n      data,\n      config,\n      childrenData,\n      loaded\n    } = this;\n    const {\n      lazy,\n      leaf\n    } = config;\n    const isLeaf = isFunction(leaf) ? leaf(data, this) : data[leaf];\n    return isUndefined(isLeaf) ? lazy && !loaded ? false : !(Array.isArray(childrenData) && childrenData.length) : !!isLeaf;\n  }\n\n  get valueByOption() {\n    return this.config.emitPath ? this.pathValues : this.value;\n  }\n\n  appendChild(childData) {\n    const {\n      childrenData,\n      children\n    } = this;\n    const node = new Node(childData, this.config, this);\n\n    if (Array.isArray(childrenData)) {\n      childrenData.push(childData);\n    } else {\n      this.childrenData = [childData];\n    }\n\n    children.push(node);\n    return node;\n  }\n\n  calcText(allLevels, separator) {\n    const text = allLevels ? this.pathLabels.join(separator) : this.label;\n    this.text = text;\n    return text;\n  }\n\n  broadcast(event, ...args) {\n    const handlerName = `onParent${capitalize(event)}`;\n    this.children.forEach(child => {\n      if (child) {\n        child.broadcast(event, ...args);\n        child[handlerName] && child[handlerName](...args);\n      }\n    });\n  }\n\n  emit(event, ...args) {\n    const {\n      parent\n    } = this;\n    const handlerName = `onChild${capitalize(event)}`;\n\n    if (parent) {\n      parent[handlerName] && parent[handlerName](...args);\n      parent.emit(event, ...args);\n    }\n  }\n\n  onParentCheck(checked) {\n    if (!this.isDisabled) {\n      this.setCheckState(checked);\n    }\n  }\n\n  onChildCheck() {\n    const {\n      children\n    } = this;\n    const validChildren = children.filter(child => !child.isDisabled);\n    const checked = validChildren.length ? validChildren.every(child => child.checked) : false;\n    this.setCheckState(checked);\n  }\n\n  setCheckState(checked) {\n    const totalNum = this.children.length;\n    const checkedNum = this.children.reduce((c, p) => {\n      const num = p.checked ? 1 : p.indeterminate ? 0.5 : 0;\n      return c + num;\n    }, 0);\n    this.checked = this.loaded && this.children.filter(child => !child.isDisabled).every(child => child.loaded && child.checked) && checked;\n    this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;\n  }\n\n  doCheck(checked) {\n    if (this.checked === checked) return;\n    const {\n      checkStrictly,\n      multiple\n    } = this.config;\n\n    if (checkStrictly || !multiple) {\n      this.checked = checked;\n    } else {\n      this.broadcast(\"check\", checked);\n      this.setCheckState(checked);\n      this.emit(\"check\");\n    }\n  }\n\n}\n\nexport { ExpandTrigger, Node as default };","map":{"version":3,"mappings":"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","names":["ExpandTrigger","ExpandTrigger2","uid","calculatePathNodes","node","nodes","parent","unshift","Node","constructor","data","config","root","checked","indeterminate","loading","value","valueKey","label","labelKey","children","childrenKey","childrenData","pathNodes","level","pathValues","map","pathLabels","child","loaded","lazy","isLeaf","isEmpty","isDisabled","disabled","checkStrictly","isFunction","leaf","isUndefined","Array","isArray","length","valueByOption","emitPath","appendChild","childData","push","calcText","allLevels","separator","text","join","broadcast","event","args","handlerName","capitalize","forEach","emit","onParentCheck","setCheckState","onChildCheck","validChildren","filter","every","totalNum","checkedNum","reduce","c","p","num","doCheck","multiple"],"sources":["../../../../../../packages/components/cascader-panel/src/node.ts"],"sourcesContent":["// @ts-nocheck\nimport { isFunction } from '@vue/shared'\nimport { capitalize, isEmpty, isUndefined } from '@element-plus/utils'\nimport type { VNode } from 'vue'\n\nexport type CascaderNodeValue = string | number\nexport type CascaderNodePathValue = CascaderNodeValue[]\nexport type CascaderValue =\n  | CascaderNodeValue\n  | CascaderNodePathValue\n  | (CascaderNodeValue | CascaderNodePathValue)[]\nexport type CascaderConfig = Required<CascaderProps>\nexport enum ExpandTrigger {\n  CLICK = 'click',\n  HOVER = 'hover',\n}\nexport type isDisabled = (data: CascaderOption, node: Node) => boolean\nexport type isLeaf = (data: CascaderOption, node: Node) => boolean\nexport type Resolve = (dataList?: CascaderOption[]) => void\nexport type LazyLoad = (node: Node, resolve: Resolve) => void\nexport type RenderLabel = ({\n  node: Node,\n  data: CascaderOption,\n}) => VNode | VNode[]\nexport interface CascaderOption extends Record<string, unknown> {\n  label?: string\n  value?: CascaderNodeValue\n  children?: CascaderOption[]\n  disabled?: boolean\n  leaf?: boolean\n}\n\nexport interface CascaderProps {\n  expandTrigger?: ExpandTrigger\n  multiple?: boolean\n  checkStrictly?: boolean\n  emitPath?: boolean\n  lazy?: boolean\n  lazyLoad?: LazyLoad\n  value?: string\n  label?: string\n  children?: string\n  disabled?: string | isDisabled\n  leaf?: string | isLeaf\n  hoverThreshold?: number\n}\n\nexport type Nullable<T> = null | T\n\ntype ChildrenData = CascaderOption[] | undefined\n\nlet uid = 0\n\nconst calculatePathNodes = (node: Node) => {\n  const nodes = [node]\n  let { parent } = node\n\n  while (parent) {\n    nodes.unshift(parent)\n    parent = parent.parent\n  }\n\n  return nodes\n}\n\nclass Node {\n  readonly uid: number = uid++\n  readonly level: number\n  readonly value: CascaderNodeValue\n  readonly label: string\n  readonly pathNodes: Node[]\n  readonly pathValues: CascaderNodePathValue\n  readonly pathLabels: string[]\n\n  childrenData: ChildrenData\n  children: Node[]\n  text: string\n  loaded: boolean\n  checked = false\n  indeterminate = false\n  loading = false\n\n  constructor(\n    readonly data: Nullable<CascaderOption>,\n    readonly config: CascaderConfig,\n    readonly parent?: Node,\n    readonly root = false\n  ) {\n    const { value: valueKey, label: labelKey, children: childrenKey } = config\n\n    const childrenData = data[childrenKey] as ChildrenData\n    const pathNodes = calculatePathNodes(this)\n\n    this.level = root ? 0 : parent ? parent.level + 1 : 1\n    this.value = data[valueKey] as CascaderNodeValue\n    this.label = data[labelKey] as string\n    this.pathNodes = pathNodes\n    this.pathValues = pathNodes.map((node) => node.value)\n    this.pathLabels = pathNodes.map((node) => node.label)\n    this.childrenData = childrenData\n    this.children = (childrenData || []).map(\n      (child) => new Node(child, config, this)\n    )\n    this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData)\n  }\n\n  get isDisabled(): boolean {\n    const { data, parent, config } = this\n    const { disabled, checkStrictly } = config\n    const isDisabled = isFunction(disabled)\n      ? disabled(data, this)\n      : !!data[disabled]\n    return isDisabled || (!checkStrictly && parent?.isDisabled)\n  }\n\n  get isLeaf(): boolean {\n    const { data, config, childrenData, loaded } = this\n    const { lazy, leaf } = config\n    const isLeaf = isFunction(leaf) ? leaf(data, this) : data[leaf]\n\n    return isUndefined(isLeaf)\n      ? lazy && !loaded\n        ? false\n        : !(Array.isArray(childrenData) && childrenData.length)\n      : !!isLeaf\n  }\n\n  get valueByOption() {\n    return this.config.emitPath ? this.pathValues : this.value\n  }\n\n  appendChild(childData: CascaderOption) {\n    const { childrenData, children } = this\n    const node = new Node(childData, this.config, this)\n\n    if (Array.isArray(childrenData)) {\n      childrenData.push(childData)\n    } else {\n      this.childrenData = [childData]\n    }\n\n    children.push(node)\n\n    return node\n  }\n\n  calcText(allLevels: boolean, separator: string) {\n    const text = allLevels ? this.pathLabels.join(separator) : this.label\n    this.text = text\n    return text\n  }\n\n  broadcast(event: string, ...args: unknown[]) {\n    const handlerName = `onParent${capitalize(event)}`\n    this.children.forEach((child) => {\n      if (child) {\n        // bottom up\n        child.broadcast(event, ...args)\n        child[handlerName] && child[handlerName](...args)\n      }\n    })\n  }\n\n  emit(event: string, ...args: unknown[]) {\n    const { parent } = this\n    const handlerName = `onChild${capitalize(event)}`\n    if (parent) {\n      parent[handlerName] && parent[handlerName](...args)\n      parent.emit(event, ...args)\n    }\n  }\n\n  onParentCheck(checked: boolean) {\n    if (!this.isDisabled) {\n      this.setCheckState(checked)\n    }\n  }\n\n  onChildCheck() {\n    const { children } = this\n    const validChildren = children.filter((child) => !child.isDisabled)\n    const checked = validChildren.length\n      ? validChildren.every((child) => child.checked)\n      : false\n\n    this.setCheckState(checked)\n  }\n\n  setCheckState(checked: boolean) {\n    const totalNum = this.children.length\n    const checkedNum = this.children.reduce((c, p) => {\n      const num = p.checked ? 1 : p.indeterminate ? 0.5 : 0\n      return c + num\n    }, 0)\n\n    this.checked =\n      this.loaded &&\n      this.children\n        .filter((child) => !child.isDisabled)\n        .every((child) => child.loaded && child.checked) &&\n      checked\n    this.indeterminate =\n      this.loaded && checkedNum !== totalNum && checkedNum > 0\n  }\n\n  doCheck(checked: boolean) {\n    if (this.checked === checked) return\n\n    const { checkStrictly, multiple } = this.config\n\n    if (checkStrictly || !multiple) {\n      this.checked = checked\n    } else {\n      // bottom up to unify the calculation of the indeterminate state\n      this.broadcast('check', checked)\n      this.setCheckState(checked)\n      this.emit('check')\n    }\n  }\n}\n\nexport default Node\n"]},"metadata":{},"sourceType":"module"}