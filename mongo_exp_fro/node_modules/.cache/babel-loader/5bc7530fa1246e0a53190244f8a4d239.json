{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport { reactive } from 'vue';\nimport '../../../../utils/index.mjs';\nimport { markNodeData, NODE_KEY } from './util.mjs';\nimport { hasOwn } from '@vue/shared';\n\nconst getChildState = node => {\n  let all = true;\n  let none = true;\n  let allWithoutDisable = true;\n\n  for (let i = 0, j = node.length; i < j; i++) {\n    const n = node[i];\n\n    if (n.checked !== true || n.indeterminate) {\n      all = false;\n\n      if (!n.disabled) {\n        allWithoutDisable = false;\n      }\n    }\n\n    if (n.checked !== false || n.indeterminate) {\n      none = false;\n    }\n  }\n\n  return {\n    all,\n    none,\n    allWithoutDisable,\n    half: !all && !none\n  };\n};\n\nconst reInitChecked = function (node) {\n  if (node.childNodes.length === 0) return;\n  const {\n    all,\n    none,\n    half\n  } = getChildState(node.childNodes);\n\n  if (all) {\n    node.checked = true;\n    node.indeterminate = false;\n  } else if (half) {\n    node.checked = false;\n    node.indeterminate = true;\n  } else if (none) {\n    node.checked = false;\n    node.indeterminate = false;\n  }\n\n  const parent = node.parent;\n  if (!parent || parent.level === 0) return;\n\n  if (!node.store.checkStrictly) {\n    reInitChecked(parent);\n  }\n};\n\nconst getPropertyFromData = function (node, prop) {\n  const props = node.store.props;\n  const data = node.data || {};\n  const config = props[prop];\n\n  if (typeof config === \"function\") {\n    return config(data, node);\n  } else if (typeof config === \"string\") {\n    return data[config];\n  } else if (typeof config === \"undefined\") {\n    const dataProp = data[prop];\n    return dataProp === void 0 ? \"\" : dataProp;\n  }\n};\n\nlet nodeIdSeed = 0;\n\nclass Node {\n  constructor(options) {\n    this.id = nodeIdSeed++;\n    this.text = null;\n    this.checked = false;\n    this.indeterminate = false;\n    this.data = null;\n    this.expanded = false;\n    this.parent = null;\n    this.visible = true;\n    this.isCurrent = false;\n    this.canFocus = false;\n\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        this[name] = options[name];\n      }\n    }\n\n    this.level = 0;\n    this.loaded = false;\n    this.childNodes = [];\n    this.loading = false;\n\n    if (this.parent) {\n      this.level = this.parent.level + 1;\n    }\n  }\n\n  initialize() {\n    const store = this.store;\n\n    if (!store) {\n      throw new Error(\"[Node]store is required!\");\n    }\n\n    store.registerNode(this);\n    const props = store.props;\n\n    if (props && typeof props.isLeaf !== \"undefined\") {\n      const isLeaf = getPropertyFromData(this, \"isLeaf\");\n\n      if (typeof isLeaf === \"boolean\") {\n        this.isLeafByUser = isLeaf;\n      }\n    }\n\n    if (store.lazy !== true && this.data) {\n      this.setData(this.data);\n\n      if (store.defaultExpandAll) {\n        this.expanded = true;\n        this.canFocus = true;\n      }\n    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {\n      this.expand();\n    }\n\n    if (!Array.isArray(this.data)) {\n      markNodeData(this, this.data);\n    }\n\n    if (!this.data) return;\n    const defaultExpandedKeys = store.defaultExpandedKeys;\n    const key = store.key;\n\n    if (key && defaultExpandedKeys && defaultExpandedKeys.includes(this.key)) {\n      this.expand(null, store.autoExpandParent);\n    }\n\n    if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {\n      store.currentNode = this;\n      store.currentNode.isCurrent = true;\n    }\n\n    if (store.lazy) {\n      store._initDefaultCheckedNode(this);\n    }\n\n    this.updateLeafState();\n    if (this.parent && (this.level === 1 || this.parent.expanded === true)) this.canFocus = true;\n  }\n\n  setData(data) {\n    if (!Array.isArray(data)) {\n      markNodeData(this, data);\n    }\n\n    this.data = data;\n    this.childNodes = [];\n    let children;\n\n    if (this.level === 0 && Array.isArray(this.data)) {\n      children = this.data;\n    } else {\n      children = getPropertyFromData(this, \"children\") || [];\n    }\n\n    for (let i = 0, j = children.length; i < j; i++) {\n      this.insertChild({\n        data: children[i]\n      });\n    }\n  }\n\n  get label() {\n    return getPropertyFromData(this, \"label\");\n  }\n\n  get key() {\n    const nodeKey = this.store.key;\n    if (this.data) return this.data[nodeKey];\n    return null;\n  }\n\n  get disabled() {\n    return getPropertyFromData(this, \"disabled\");\n  }\n\n  get nextSibling() {\n    const parent = this.parent;\n\n    if (parent) {\n      const index = parent.childNodes.indexOf(this);\n\n      if (index > -1) {\n        return parent.childNodes[index + 1];\n      }\n    }\n\n    return null;\n  }\n\n  get previousSibling() {\n    const parent = this.parent;\n\n    if (parent) {\n      const index = parent.childNodes.indexOf(this);\n\n      if (index > -1) {\n        return index > 0 ? parent.childNodes[index - 1] : null;\n      }\n    }\n\n    return null;\n  }\n\n  contains(target, deep = true) {\n    return (this.childNodes || []).some(child => child === target || deep && child.contains(target));\n  }\n\n  remove() {\n    const parent = this.parent;\n\n    if (parent) {\n      parent.removeChild(this);\n    }\n  }\n\n  insertChild(child, index, batch) {\n    if (!child) throw new Error(\"InsertChild error: child is required.\");\n\n    if (!(child instanceof Node)) {\n      if (!batch) {\n        const children = this.getChildren(true);\n\n        if (!children.includes(child.data)) {\n          if (typeof index === \"undefined\" || index < 0) {\n            children.push(child.data);\n          } else {\n            children.splice(index, 0, child.data);\n          }\n        }\n      }\n\n      Object.assign(child, {\n        parent: this,\n        store: this.store\n      });\n      child = reactive(new Node(child));\n\n      if (child instanceof Node) {\n        child.initialize();\n      }\n    }\n\n    ;\n    child.level = this.level + 1;\n\n    if (typeof index === \"undefined\" || index < 0) {\n      this.childNodes.push(child);\n    } else {\n      this.childNodes.splice(index, 0, child);\n    }\n\n    this.updateLeafState();\n  }\n\n  insertBefore(child, ref) {\n    let index;\n\n    if (ref) {\n      index = this.childNodes.indexOf(ref);\n    }\n\n    this.insertChild(child, index);\n  }\n\n  insertAfter(child, ref) {\n    let index;\n\n    if (ref) {\n      index = this.childNodes.indexOf(ref);\n      if (index !== -1) index += 1;\n    }\n\n    this.insertChild(child, index);\n  }\n\n  removeChild(child) {\n    const children = this.getChildren() || [];\n    const dataIndex = children.indexOf(child.data);\n\n    if (dataIndex > -1) {\n      children.splice(dataIndex, 1);\n    }\n\n    const index = this.childNodes.indexOf(child);\n\n    if (index > -1) {\n      this.store && this.store.deregisterNode(child);\n      child.parent = null;\n      this.childNodes.splice(index, 1);\n    }\n\n    this.updateLeafState();\n  }\n\n  removeChildByData(data) {\n    let targetNode = null;\n\n    for (let i = 0; i < this.childNodes.length; i++) {\n      if (this.childNodes[i].data === data) {\n        targetNode = this.childNodes[i];\n        break;\n      }\n    }\n\n    if (targetNode) {\n      this.removeChild(targetNode);\n    }\n  }\n\n  expand(callback, expandParent) {\n    const done = () => {\n      if (expandParent) {\n        let parent = this.parent;\n\n        while (parent.level > 0) {\n          parent.expanded = true;\n          parent = parent.parent;\n        }\n      }\n\n      this.expanded = true;\n      if (callback) callback();\n      this.childNodes.forEach(item => {\n        item.canFocus = true;\n      });\n    };\n\n    if (this.shouldLoadData()) {\n      this.loadData(data => {\n        if (Array.isArray(data)) {\n          if (this.checked) {\n            this.setChecked(true, true);\n          } else if (!this.store.checkStrictly) {\n            reInitChecked(this);\n          }\n\n          done();\n        }\n      });\n    } else {\n      done();\n    }\n  }\n\n  doCreateChildren(array, defaultProps = {}) {\n    array.forEach(item => {\n      this.insertChild(Object.assign({\n        data: item\n      }, defaultProps), void 0, true);\n    });\n  }\n\n  collapse() {\n    this.expanded = false;\n    this.childNodes.forEach(item => {\n      item.canFocus = false;\n    });\n  }\n\n  shouldLoadData() {\n    return this.store.lazy === true && this.store.load && !this.loaded;\n  }\n\n  updateLeafState() {\n    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== \"undefined\") {\n      this.isLeaf = this.isLeafByUser;\n      return;\n    }\n\n    const childNodes = this.childNodes;\n\n    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {\n      this.isLeaf = !childNodes || childNodes.length === 0;\n      return;\n    }\n\n    this.isLeaf = false;\n  }\n\n  setChecked(value, deep, recursion, passValue) {\n    this.indeterminate = value === \"half\";\n    this.checked = value === true;\n    if (this.store.checkStrictly) return;\n\n    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n      const {\n        all,\n        allWithoutDisable\n      } = getChildState(this.childNodes);\n\n      if (!this.isLeaf && !all && allWithoutDisable) {\n        this.checked = false;\n        value = false;\n      }\n\n      const handleDescendants = () => {\n        if (deep) {\n          const childNodes = this.childNodes;\n\n          for (let i = 0, j = childNodes.length; i < j; i++) {\n            const child = childNodes[i];\n            passValue = passValue || value !== false;\n            const isCheck = child.disabled ? child.checked : passValue;\n            child.setChecked(isCheck, deep, true, passValue);\n          }\n\n          const {\n            half,\n            all: all2\n          } = getChildState(childNodes);\n\n          if (!all2) {\n            this.checked = all2;\n            this.indeterminate = half;\n          }\n        }\n      };\n\n      if (this.shouldLoadData()) {\n        this.loadData(() => {\n          handleDescendants();\n          reInitChecked(this);\n        }, {\n          checked: value !== false\n        });\n        return;\n      } else {\n        handleDescendants();\n      }\n    }\n\n    const parent = this.parent;\n    if (!parent || parent.level === 0) return;\n\n    if (!recursion) {\n      reInitChecked(parent);\n    }\n  }\n\n  getChildren(forceInit = false) {\n    if (this.level === 0) return this.data;\n    const data = this.data;\n    if (!data) return null;\n    const props = this.store.props;\n    let children = \"children\";\n\n    if (props) {\n      children = props.children || \"children\";\n    }\n\n    if (data[children] === void 0) {\n      data[children] = null;\n    }\n\n    if (forceInit && !data[children]) {\n      data[children] = [];\n    }\n\n    return data[children];\n  }\n\n  updateChildren() {\n    const newData = this.getChildren() || [];\n    const oldData = this.childNodes.map(node => node.data);\n    const newDataMap = {};\n    const newNodes = [];\n    newData.forEach((item, index) => {\n      const key = item[NODE_KEY];\n      const isNodeExists = !!key && oldData.findIndex(data => data[NODE_KEY] === key) >= 0;\n\n      if (isNodeExists) {\n        newDataMap[key] = {\n          index,\n          data: item\n        };\n      } else {\n        newNodes.push({\n          index,\n          data: item\n        });\n      }\n    });\n\n    if (!this.store.lazy) {\n      oldData.forEach(item => {\n        if (!newDataMap[item[NODE_KEY]]) this.removeChildByData(item);\n      });\n    }\n\n    newNodes.forEach(({\n      index,\n      data\n    }) => {\n      this.insertChild({\n        data\n      }, index);\n    });\n    this.updateLeafState();\n  }\n\n  loadData(callback, defaultProps = {}) {\n    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {\n      this.loading = true;\n\n      const resolve = children => {\n        this.loaded = true;\n        this.loading = false;\n        this.childNodes = [];\n        this.doCreateChildren(children, defaultProps);\n        this.updateLeafState();\n\n        if (callback) {\n          callback.call(this, children);\n        }\n      };\n\n      this.store.load(this, resolve);\n    } else {\n      if (callback) {\n        callback.call(this);\n      }\n    }\n  }\n\n}\n\nexport { Node as default, getChildState };","map":{"version":3,"mappings":"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","names":["getChildState","node","all","none","allWithoutDisable","i","j","length","n","checked","indeterminate","disabled","half","reInitChecked","childNodes","parent","level","store","checkStrictly","getPropertyFromData","prop","props","data","config","dataProp","nodeIdSeed","Node","constructor","options","id","text","expanded","visible","isCurrent","canFocus","name","hasOwn","loaded","loading","initialize","Error","registerNode","isLeaf","isLeafByUser","lazy","setData","defaultExpandAll","expand","Array","isArray","markNodeData","defaultExpandedKeys","key","includes","autoExpandParent","currentNodeKey","currentNode","_initDefaultCheckedNode","updateLeafState","children","insertChild","label","nodeKey","nextSibling","index","indexOf","previousSibling","contains","target","deep","some","child","remove","removeChild","batch","getChildren","push","splice","Object","assign","reactive","insertBefore","ref","insertAfter","dataIndex","deregisterNode","removeChildByData","targetNode","callback","expandParent","done","forEach","item","shouldLoadData","loadData","setChecked","doCreateChildren","array","defaultProps","collapse","load","value","recursion","passValue","checkDescendants","handleDescendants","isCheck","all2","forceInit","updateChildren","newData","oldData","map","newDataMap","newNodes","NODE_KEY","isNodeExists","findIndex","keys","resolve","call"],"sources":["../../../../../../../packages/components/tree/src/model/node.ts"],"sourcesContent":["// @ts-nocheck\nimport { reactive } from 'vue'\nimport { hasOwn } from '@element-plus/utils'\nimport { NODE_KEY, markNodeData } from './util'\nimport type TreeStore from './tree-store'\n\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  FakeNode,\n  TreeKey,\n  TreeNodeChildState,\n  TreeNodeData,\n  TreeNodeLoadedDefaultProps,\n  TreeNodeOptions,\n} from '../tree.type'\n\nexport const getChildState = (node: Node[]): TreeNodeChildState => {\n  let all = true\n  let none = true\n  let allWithoutDisable = true\n  for (let i = 0, j = node.length; i < j; i++) {\n    const n = node[i]\n    if (n.checked !== true || n.indeterminate) {\n      all = false\n      if (!n.disabled) {\n        allWithoutDisable = false\n      }\n    }\n    if (n.checked !== false || n.indeterminate) {\n      none = false\n    }\n  }\n\n  return { all, none, allWithoutDisable, half: !all && !none }\n}\n\nconst reInitChecked = function (node: Node): void {\n  if (node.childNodes.length === 0) return\n\n  const { all, none, half } = getChildState(node.childNodes)\n  if (all) {\n    node.checked = true\n    node.indeterminate = false\n  } else if (half) {\n    node.checked = false\n    node.indeterminate = true\n  } else if (none) {\n    node.checked = false\n    node.indeterminate = false\n  }\n\n  const parent = node.parent\n  if (!parent || parent.level === 0) return\n\n  if (!node.store.checkStrictly) {\n    reInitChecked(parent)\n  }\n}\n\nconst getPropertyFromData = function (node: Node, prop: string): any {\n  const props = node.store.props\n  const data = node.data || {}\n  const config = props[prop]\n\n  if (typeof config === 'function') {\n    return config(data, node)\n  } else if (typeof config === 'string') {\n    return data[config]\n  } else if (typeof config === 'undefined') {\n    const dataProp = data[prop]\n    return dataProp === undefined ? '' : dataProp\n  }\n}\n\nlet nodeIdSeed = 0\n\nclass Node {\n  id: number\n  text: string\n  checked: boolean\n  indeterminate: boolean\n  data: TreeNodeData\n  expanded: boolean\n  parent: Node\n  visible: boolean\n  isCurrent: boolean\n  store: TreeStore\n  isLeafByUser: boolean\n  isLeaf: boolean\n  canFocus: boolean\n\n  level: number\n  loaded: boolean\n  childNodes: Node[]\n  loading: boolean\n\n  constructor(options: TreeNodeOptions) {\n    this.id = nodeIdSeed++\n    this.text = null\n    this.checked = false\n    this.indeterminate = false\n    this.data = null\n    this.expanded = false\n    this.parent = null\n    this.visible = true\n    this.isCurrent = false\n    this.canFocus = false\n\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        this[name] = options[name]\n      }\n    }\n\n    // internal\n    this.level = 0\n    this.loaded = false\n    this.childNodes = []\n    this.loading = false\n\n    if (this.parent) {\n      this.level = this.parent.level + 1\n    }\n  }\n\n  initialize() {\n    const store = this.store\n    if (!store) {\n      throw new Error('[Node]store is required!')\n    }\n    store.registerNode(this)\n\n    const props = store.props\n    if (props && typeof props.isLeaf !== 'undefined') {\n      const isLeaf = getPropertyFromData(this, 'isLeaf')\n      if (typeof isLeaf === 'boolean') {\n        this.isLeafByUser = isLeaf\n      }\n    }\n\n    if (store.lazy !== true && this.data) {\n      this.setData(this.data)\n\n      if (store.defaultExpandAll) {\n        this.expanded = true\n        this.canFocus = true\n      }\n    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {\n      this.expand()\n    }\n    if (!Array.isArray(this.data)) {\n      markNodeData(this, this.data)\n    }\n    if (!this.data) return\n\n    const defaultExpandedKeys = store.defaultExpandedKeys\n    const key = store.key\n\n    if (key && defaultExpandedKeys && defaultExpandedKeys.includes(this.key)) {\n      this.expand(null, store.autoExpandParent)\n    }\n\n    if (\n      key &&\n      store.currentNodeKey !== undefined &&\n      this.key === store.currentNodeKey\n    ) {\n      store.currentNode = this\n      store.currentNode.isCurrent = true\n    }\n\n    if (store.lazy) {\n      store._initDefaultCheckedNode(this)\n    }\n\n    this.updateLeafState()\n    if (this.parent && (this.level === 1 || this.parent.expanded === true))\n      this.canFocus = true\n  }\n\n  setData(data: TreeNodeData): void {\n    if (!Array.isArray(data)) {\n      markNodeData(this, data)\n    }\n\n    this.data = data\n    this.childNodes = []\n\n    let children\n    if (this.level === 0 && Array.isArray(this.data)) {\n      children = this.data\n    } else {\n      children = getPropertyFromData(this, 'children') || []\n    }\n\n    for (let i = 0, j = children.length; i < j; i++) {\n      this.insertChild({ data: children[i] })\n    }\n  }\n\n  get label(): string {\n    return getPropertyFromData(this, 'label')\n  }\n\n  get key(): TreeKey {\n    const nodeKey = this.store.key\n    if (this.data) return this.data[nodeKey]\n    return null\n  }\n\n  get disabled(): boolean {\n    return getPropertyFromData(this, 'disabled')\n  }\n\n  get nextSibling(): Nullable<Node> {\n    const parent = this.parent\n    if (parent) {\n      const index = parent.childNodes.indexOf(this)\n      if (index > -1) {\n        return parent.childNodes[index + 1]\n      }\n    }\n    return null\n  }\n\n  get previousSibling(): Nullable<Node> {\n    const parent = this.parent\n    if (parent) {\n      const index = parent.childNodes.indexOf(this)\n      if (index > -1) {\n        return index > 0 ? parent.childNodes[index - 1] : null\n      }\n    }\n    return null\n  }\n\n  contains(target: Node, deep = true): boolean {\n    return (this.childNodes || []).some(\n      (child) => child === target || (deep && child.contains(target))\n    )\n  }\n\n  remove(): void {\n    const parent = this.parent\n    if (parent) {\n      parent.removeChild(this)\n    }\n  }\n\n  insertChild(child?: FakeNode | Node, index?: number, batch?: boolean): void {\n    if (!child) throw new Error('InsertChild error: child is required.')\n\n    if (!(child instanceof Node)) {\n      if (!batch) {\n        const children = this.getChildren(true)\n        if (!children.includes(child.data)) {\n          if (typeof index === 'undefined' || index < 0) {\n            children.push(child.data)\n          } else {\n            children.splice(index, 0, child.data)\n          }\n        }\n      }\n      Object.assign(child, {\n        parent: this,\n        store: this.store,\n      })\n      child = reactive(new Node(child as TreeNodeOptions))\n      if (child instanceof Node) {\n        child.initialize()\n      }\n    }\n\n    ;(child as Node).level = this.level + 1\n\n    if (typeof index === 'undefined' || index < 0) {\n      this.childNodes.push(child as Node)\n    } else {\n      this.childNodes.splice(index, 0, child as Node)\n    }\n\n    this.updateLeafState()\n  }\n\n  insertBefore(child: FakeNode | Node, ref: Node): void {\n    let index\n    if (ref) {\n      index = this.childNodes.indexOf(ref)\n    }\n    this.insertChild(child, index)\n  }\n\n  insertAfter(child: FakeNode | Node, ref: Node): void {\n    let index\n    if (ref) {\n      index = this.childNodes.indexOf(ref)\n      if (index !== -1) index += 1\n    }\n    this.insertChild(child, index)\n  }\n\n  removeChild(child: Node): void {\n    const children = this.getChildren() || []\n    const dataIndex = children.indexOf(child.data)\n    if (dataIndex > -1) {\n      children.splice(dataIndex, 1)\n    }\n\n    const index = this.childNodes.indexOf(child)\n\n    if (index > -1) {\n      this.store && this.store.deregisterNode(child)\n      child.parent = null\n      this.childNodes.splice(index, 1)\n    }\n\n    this.updateLeafState()\n  }\n\n  removeChildByData(data: TreeNodeData): void {\n    let targetNode: Node = null\n\n    for (let i = 0; i < this.childNodes.length; i++) {\n      if (this.childNodes[i].data === data) {\n        targetNode = this.childNodes[i]\n        break\n      }\n    }\n\n    if (targetNode) {\n      this.removeChild(targetNode)\n    }\n  }\n\n  expand(callback?: () => void, expandParent?: boolean): void {\n    const done = (): void => {\n      if (expandParent) {\n        let parent = this.parent\n        while (parent.level > 0) {\n          parent.expanded = true\n          parent = parent.parent\n        }\n      }\n      this.expanded = true\n      if (callback) callback()\n      this.childNodes.forEach((item) => {\n        item.canFocus = true\n      })\n    }\n\n    if (this.shouldLoadData()) {\n      this.loadData((data) => {\n        if (Array.isArray(data)) {\n          if (this.checked) {\n            this.setChecked(true, true)\n          } else if (!this.store.checkStrictly) {\n            reInitChecked(this)\n          }\n          done()\n        }\n      })\n    } else {\n      done()\n    }\n  }\n\n  doCreateChildren(\n    array: TreeNodeData[],\n    defaultProps: TreeNodeLoadedDefaultProps = {}\n  ): void {\n    array.forEach((item) => {\n      this.insertChild(\n        Object.assign({ data: item }, defaultProps),\n        undefined,\n        true\n      )\n    })\n  }\n\n  collapse(): void {\n    this.expanded = false\n    this.childNodes.forEach((item) => {\n      item.canFocus = false\n    })\n  }\n\n  shouldLoadData(): boolean {\n    return this.store.lazy === true && this.store.load && !this.loaded\n  }\n\n  updateLeafState(): void {\n    if (\n      this.store.lazy === true &&\n      this.loaded !== true &&\n      typeof this.isLeafByUser !== 'undefined'\n    ) {\n      this.isLeaf = this.isLeafByUser\n      return\n    }\n    const childNodes = this.childNodes\n    if (\n      !this.store.lazy ||\n      (this.store.lazy === true && this.loaded === true)\n    ) {\n      this.isLeaf = !childNodes || childNodes.length === 0\n      return\n    }\n    this.isLeaf = false\n  }\n\n  setChecked(\n    value?: boolean | string,\n    deep?: boolean,\n    recursion?: boolean,\n    passValue?: boolean\n  ) {\n    this.indeterminate = value === 'half'\n    this.checked = value === true\n\n    if (this.store.checkStrictly) return\n\n    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n      const { all, allWithoutDisable } = getChildState(this.childNodes)\n\n      if (!this.isLeaf && !all && allWithoutDisable) {\n        this.checked = false\n        value = false\n      }\n\n      const handleDescendants = (): void => {\n        if (deep) {\n          const childNodes = this.childNodes\n          for (let i = 0, j = childNodes.length; i < j; i++) {\n            const child = childNodes[i]\n            passValue = passValue || value !== false\n            const isCheck = child.disabled ? child.checked : passValue\n            child.setChecked(isCheck, deep, true, passValue)\n          }\n          const { half, all } = getChildState(childNodes)\n          if (!all) {\n            this.checked = all\n            this.indeterminate = half\n          }\n        }\n      }\n\n      if (this.shouldLoadData()) {\n        // Only work on lazy load data.\n        this.loadData(\n          () => {\n            handleDescendants()\n            reInitChecked(this)\n          },\n          {\n            checked: value !== false,\n          }\n        )\n        return\n      } else {\n        handleDescendants()\n      }\n    }\n\n    const parent = this.parent\n    if (!parent || parent.level === 0) return\n\n    if (!recursion) {\n      reInitChecked(parent)\n    }\n  }\n\n  getChildren(forceInit = false): TreeNodeData | TreeNodeData[] {\n    // this is data\n    if (this.level === 0) return this.data\n    const data = this.data\n    if (!data) return null\n\n    const props = this.store.props\n    let children = 'children'\n    if (props) {\n      children = props.children || 'children'\n    }\n\n    if (data[children] === undefined) {\n      data[children] = null\n    }\n\n    if (forceInit && !data[children]) {\n      data[children] = []\n    }\n\n    return data[children]\n  }\n\n  updateChildren(): void {\n    const newData = (this.getChildren() || []) as TreeNodeData[]\n    const oldData = this.childNodes.map((node) => node.data)\n\n    const newDataMap = {}\n    const newNodes = []\n\n    newData.forEach((item, index) => {\n      const key = item[NODE_KEY]\n      const isNodeExists =\n        !!key && oldData.findIndex((data) => data[NODE_KEY] === key) >= 0\n      if (isNodeExists) {\n        newDataMap[key] = { index, data: item }\n      } else {\n        newNodes.push({ index, data: item })\n      }\n    })\n\n    if (!this.store.lazy) {\n      oldData.forEach((item) => {\n        if (!newDataMap[item[NODE_KEY]]) this.removeChildByData(item)\n      })\n    }\n\n    newNodes.forEach(({ index, data }) => {\n      this.insertChild({ data }, index)\n    })\n\n    this.updateLeafState()\n  }\n\n  loadData(\n    callback: (node: Node) => void,\n    defaultProps: TreeNodeLoadedDefaultProps = {}\n  ) {\n    if (\n      this.store.lazy === true &&\n      this.store.load &&\n      !this.loaded &&\n      (!this.loading || Object.keys(defaultProps).length)\n    ) {\n      this.loading = true\n\n      const resolve = (children) => {\n        this.loaded = true\n        this.loading = false\n        this.childNodes = []\n\n        this.doCreateChildren(children, defaultProps)\n\n        this.updateLeafState()\n        if (callback) {\n          callback.call(this, children)\n        }\n      }\n\n      this.store.load(this, resolve)\n    } else {\n      if (callback) {\n        callback.call(this)\n      }\n    }\n  }\n}\n\nexport default Node\n"]},"metadata":{},"sourceType":"module"}