{"ast":null,"code":"import { defineComponent, ref, computed, nextTick, provide, reactive, watch, onBeforeUpdate, onMounted, resolveComponent, openBlock, createElementBlock, normalizeClass, Fragment, renderList, createBlock } from 'vue';\nimport { isEqual, flattenDeep } from 'lodash-unified';\nimport { isClient } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../constants/index.mjs';\nimport '../../../hooks/index.mjs';\nimport ElCascaderMenu from './menu.mjs';\nimport Store from './store.mjs';\nimport Node, { ExpandTrigger } from './node.mjs';\nimport { CommonProps, useCascaderConfig } from './config.mjs';\nimport { sortByOriginalOrder, checkNode, getMenuIndex } from './utils.mjs';\nimport { CASCADER_PANEL_INJECTION_KEY } from './types.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { UPDATE_MODEL_EVENT, CHANGE_EVENT } from '../../../constants/event.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { isEmpty } from '../../../utils/types.mjs';\nimport { unique, castArray } from '../../../utils/arrays.mjs';\nimport { scrollIntoView } from '../../../utils/dom/scroll.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { focusNode, getSibling } from '../../../utils/dom/aria.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"ElCascaderPanel\",\n  components: {\n    ElCascaderMenu\n  },\n  props: { ...CommonProps,\n    border: {\n      type: Boolean,\n      default: true\n    },\n    renderLabel: Function\n  },\n  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, \"close\", \"expand-change\"],\n\n  setup(props, {\n    emit,\n    slots\n  }) {\n    let manualChecked = false;\n    const ns = useNamespace(\"cascader\");\n    const config = useCascaderConfig(props);\n    let store = null;\n    const initialLoaded = ref(true);\n    const menuList = ref([]);\n    const checkedValue = ref(null);\n    const menus = ref([]);\n    const expandingNode = ref(null);\n    const checkedNodes = ref([]);\n    const isHoverMenu = computed(() => config.value.expandTrigger === ExpandTrigger.HOVER);\n    const renderLabelFn = computed(() => props.renderLabel || slots.default);\n\n    const initStore = () => {\n      const {\n        options\n      } = props;\n      const cfg = config.value;\n      manualChecked = false;\n      store = new Store(options, cfg);\n      menus.value = [store.getNodes()];\n\n      if (cfg.lazy && isEmpty(props.options)) {\n        initialLoaded.value = false;\n        lazyLoad(void 0, list => {\n          if (list) {\n            store = new Store(list, cfg);\n            menus.value = [store.getNodes()];\n          }\n\n          initialLoaded.value = true;\n          syncCheckedValue(false, true);\n        });\n      } else {\n        syncCheckedValue(false, true);\n      }\n    };\n\n    const lazyLoad = (node, cb) => {\n      const cfg = config.value;\n      node = node || new Node({}, cfg, void 0, true);\n      node.loading = true;\n\n      const resolve = dataList => {\n        const _node = node;\n        const parent = _node.root ? null : _node;\n        dataList && (store == null ? void 0 : store.appendNodes(dataList, parent));\n        _node.loading = false;\n        _node.loaded = true;\n        _node.childrenData = _node.childrenData || [];\n        cb && cb(dataList);\n      };\n\n      cfg.lazyLoad(node, resolve);\n    };\n\n    const expandNode = (node, silent) => {\n      var _a;\n\n      const {\n        level\n      } = node;\n      const newMenus = menus.value.slice(0, level);\n      let newExpandingNode;\n\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2];\n      } else {\n        newExpandingNode = node;\n        newMenus.push(node.children);\n      }\n\n      if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {\n        expandingNode.value = node;\n        menus.value = newMenus;\n        !silent && emit(\"expand-change\", (node == null ? void 0 : node.pathValues) || []);\n      }\n    };\n\n    const handleCheckChange = (node, checked, emitClose = true) => {\n      const {\n        checkStrictly,\n        multiple\n      } = config.value;\n      const oldNode = checkedNodes.value[0];\n      manualChecked = true;\n      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));\n      node.doCheck(checked);\n      calculateCheckedValue();\n      emitClose && !multiple && !checkStrictly && emit(\"close\");\n      !emitClose && !multiple && !checkStrictly && expandParentNode(node);\n    };\n\n    const expandParentNode = node => {\n      if (!node) return;\n      node = node.parent;\n      expandParentNode(node);\n      node && expandNode(node);\n    };\n\n    const getFlattedNodes = leafOnly => {\n      return store == null ? void 0 : store.getFlattedNodes(leafOnly);\n    };\n\n    const getCheckedNodes = leafOnly => {\n      var _a;\n\n      return (_a = getFlattedNodes(leafOnly)) == null ? void 0 : _a.filter(node => node.checked !== false);\n    };\n\n    const clearCheckedNodes = () => {\n      checkedNodes.value.forEach(node => node.doCheck(false));\n      calculateCheckedValue();\n    };\n\n    const calculateCheckedValue = () => {\n      var _a;\n\n      const {\n        checkStrictly,\n        multiple\n      } = config.value;\n      const oldNodes = checkedNodes.value;\n      const newNodes = getCheckedNodes(!checkStrictly);\n      const nodes = sortByOriginalOrder(oldNodes, newNodes);\n      const values = nodes.map(node => node.valueByOption);\n      checkedNodes.value = nodes;\n      checkedValue.value = multiple ? values : (_a = values[0]) != null ? _a : null;\n    };\n\n    const syncCheckedValue = (loaded = false, forced = false) => {\n      const {\n        modelValue\n      } = props;\n      const {\n        lazy,\n        multiple,\n        checkStrictly\n      } = config.value;\n      const leafOnly = !checkStrictly;\n      if (!initialLoaded.value || manualChecked || !forced && isEqual(modelValue, checkedValue.value)) return;\n\n      if (lazy && !loaded) {\n        const values = unique(flattenDeep(castArray(modelValue)));\n        const nodes = values.map(val => store == null ? void 0 : store.getNodeByValue(val)).filter(node => !!node && !node.loaded && !node.loading);\n\n        if (nodes.length) {\n          nodes.forEach(node => {\n            lazyLoad(node, () => syncCheckedValue(false, forced));\n          });\n        } else {\n          syncCheckedValue(true, forced);\n        }\n      } else {\n        const values = multiple ? castArray(modelValue) : [modelValue];\n        const nodes = unique(values.map(val => store == null ? void 0 : store.getNodeByValue(val, leafOnly)));\n        syncMenuState(nodes, forced);\n        checkedValue.value = modelValue;\n      }\n    };\n\n    const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {\n      const {\n        checkStrictly\n      } = config.value;\n      const oldNodes = checkedNodes.value;\n      const newNodes = newCheckedNodes.filter(node => !!node && (checkStrictly || node.isLeaf));\n      const oldExpandingNode = store == null ? void 0 : store.getSameNode(expandingNode.value);\n      const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];\n\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach(node => expandNode(node, true));\n      } else {\n        expandingNode.value = null;\n      }\n\n      oldNodes.forEach(node => node.doCheck(false));\n      newNodes.forEach(node => node.doCheck(true));\n      checkedNodes.value = newNodes;\n      nextTick(scrollToExpandingNode);\n    };\n\n    const scrollToExpandingNode = () => {\n      if (!isClient) return;\n      menuList.value.forEach(menu => {\n        const menuElement = menu == null ? void 0 : menu.$el;\n\n        if (menuElement) {\n          const container = menuElement.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);\n          const activeNode = menuElement.querySelector(`.${ns.b(\"node\")}.${ns.is(\"active\")}`) || menuElement.querySelector(`.${ns.b(\"node\")}.in-active-path`);\n          scrollIntoView(container, activeNode);\n        }\n      });\n    };\n\n    const handleKeyDown = e => {\n      const target = e.target;\n      const {\n        code\n      } = e;\n\n      switch (code) {\n        case EVENT_CODE.up:\n        case EVENT_CODE.down:\n          {\n            e.preventDefault();\n            const distance = code === EVENT_CODE.up ? -1 : 1;\n            focusNode(getSibling(target, distance, `.${ns.b(\"node\")}[tabindex=\"-1\"]`));\n            break;\n          }\n\n        case EVENT_CODE.left:\n          {\n            e.preventDefault();\n            const preMenu = menuList.value[getMenuIndex(target) - 1];\n            const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector(`.${ns.b(\"node\")}[aria-expanded=\"true\"]`);\n            focusNode(expandedNode);\n            break;\n          }\n\n        case EVENT_CODE.right:\n          {\n            e.preventDefault();\n            const nextMenu = menuList.value[getMenuIndex(target) + 1];\n            const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector(`.${ns.b(\"node\")}[tabindex=\"-1\"]`);\n            focusNode(firstNode);\n            break;\n          }\n\n        case EVENT_CODE.enter:\n          checkNode(target);\n          break;\n      }\n    };\n\n    provide(CASCADER_PANEL_INJECTION_KEY, reactive({\n      config,\n      expandingNode,\n      checkedNodes,\n      isHoverMenu,\n      initialLoaded,\n      renderLabelFn,\n      lazyLoad,\n      expandNode,\n      handleCheckChange\n    }));\n    watch([config, () => props.options], initStore, {\n      deep: true,\n      immediate: true\n    });\n    watch(() => props.modelValue, () => {\n      manualChecked = false;\n      syncCheckedValue();\n    });\n    watch(checkedValue, val => {\n      if (!isEqual(val, props.modelValue)) {\n        emit(UPDATE_MODEL_EVENT, val);\n        emit(CHANGE_EVENT, val);\n      }\n    });\n    onBeforeUpdate(() => menuList.value = []);\n    onMounted(() => !isEmpty(props.modelValue) && syncCheckedValue());\n    return {\n      ns,\n      menuList,\n      menus,\n      checkedNodes,\n      handleKeyDown,\n      handleCheckChange,\n      getFlattedNodes,\n      getCheckedNodes,\n      clearCheckedNodes,\n      calculateCheckedValue,\n      scrollToExpandingNode\n    };\n  }\n\n});\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_el_cascader_menu = resolveComponent(\"el-cascader-menu\");\n\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass([_ctx.ns.b(\"panel\"), _ctx.ns.is(\"bordered\", _ctx.border)]),\n    onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args))\n  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menus, (menu, index) => {\n    return openBlock(), createBlock(_component_el_cascader_menu, {\n      key: index,\n      ref_for: true,\n      ref: item => _ctx.menuList[index] = item,\n      index,\n      nodes: [...menu]\n    }, null, 8, [\"index\", \"nodes\"]);\n  }), 128))], 34);\n}\n\nvar CascaderPanel = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue\"]]);\n\nexport { CascaderPanel as default };","map":{"version":3,"mappings":"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","names":["_sfc_main","defineComponent","name","components","ElCascaderMenu","props","CommonProps","border","type","default","renderLabel","emits","UPDATE_MODEL_EVENT","CHANGE_EVENT","setup","emit","slots","manualChecked","useNamespace","useCascaderConfig","store","ref","isHoverMenu","computed","config","value","expandTrigger","ExpandTrigger","HOVER","renderLabelFn","initStore","options","cfg","Store","menus","isEmpty","initialLoaded","lazyLoad","list","syncCheckedValue","node","cb","Node","loading","dataList","_node","parent","loaded","resolve","silent","level","newExpandingNode","newMenus","_a","expandingNode","emitClose","checkStrictly","multiple","oldNode","calculateCheckedValue","expandParentNode","leafOnly","checkedNodes","oldNodes","sortByOriginalOrder","nodes","checkedValue","modelValue","lazy","isEqual","values","val","filter","syncMenuState","newNodes","forEach","nextTick","menuList","menu","scrollIntoView","code","e","focusNode","checkNode","provide","expandNode","handleCheckChange","watch","deep","immediate","onBeforeUpdate","onMounted","ns","handleKeyDown","getFlattedNodes","getCheckedNodes","clearCheckedNodes","scrollToExpandingNode","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","class","_openBlock","key","ref_for"],"sources":["../../../../../../packages/components/cascader-panel/src/index.vue"],"sourcesContent":["<template>\n  <div\n    :class=\"[ns.b('panel'), ns.is('bordered', border)]\"\n    @keydown=\"handleKeyDown\"\n  >\n    <el-cascader-menu\n      v-for=\"(menu, index) in menus\"\n      :key=\"index\"\n      :ref=\"(item) => (menuList[index] = item)\"\n      :index=\"index\"\n      :nodes=\"[...menu]\"\n    />\n  </div>\n</template>\n\n<script lang=\"ts\">\n// @ts-nocheck\nimport {\n  computed,\n  defineComponent,\n  nextTick,\n  onBeforeUpdate,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  watch,\n} from 'vue'\nimport { flattenDeep, isEqual } from 'lodash-unified'\nimport { isClient } from '@vueuse/core'\nimport {\n  castArray,\n  focusNode,\n  getSibling,\n  isEmpty,\n  scrollIntoView,\n  unique,\n} from '@element-plus/utils'\nimport {\n  CHANGE_EVENT,\n  EVENT_CODE,\n  UPDATE_MODEL_EVENT,\n} from '@element-plus/constants'\nimport { useNamespace } from '@element-plus/hooks'\n\nimport ElCascaderMenu from './menu.vue'\nimport Store from './store'\nimport Node, { ExpandTrigger } from './node'\nimport { CommonProps, useCascaderConfig } from './config'\nimport { checkNode, getMenuIndex, sortByOriginalOrder } from './utils'\nimport { CASCADER_PANEL_INJECTION_KEY } from './types'\n\nimport type { PropType } from 'vue'\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  default as CascaderNode,\n  CascaderNodeValue,\n  CascaderOption,\n  CascaderValue,\n  RenderLabel,\n} from './node'\n\nimport type { ElCascaderPanelContext } from './types'\n\nexport default defineComponent({\n  name: 'ElCascaderPanel',\n\n  components: {\n    ElCascaderMenu,\n  },\n\n  props: {\n    ...CommonProps,\n    border: {\n      type: Boolean,\n      default: true,\n    },\n    renderLabel: Function as PropType<RenderLabel>,\n  },\n\n  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'close', 'expand-change'],\n\n  setup(props, { emit, slots }) {\n    // for interrupt sync check status in lazy mode\n    let manualChecked = false\n\n    const ns = useNamespace('cascader')\n    const config = useCascaderConfig(props)\n\n    let store: Nullable<Store> = null\n    const initialLoaded = ref(true)\n    const menuList = ref<any[]>([])\n    const checkedValue = ref<Nullable<CascaderValue>>(null)\n    const menus = ref<CascaderNode[][]>([])\n    const expandingNode = ref<Nullable<CascaderNode>>(null)\n    const checkedNodes = ref<CascaderNode[]>([])\n\n    const isHoverMenu = computed(\n      () => config.value.expandTrigger === ExpandTrigger.HOVER\n    )\n    const renderLabelFn = computed(() => props.renderLabel || slots.default)\n\n    const initStore = () => {\n      const { options } = props\n      const cfg = config.value\n\n      manualChecked = false\n      store = new Store(options, cfg)\n      menus.value = [store.getNodes()]\n\n      if (cfg.lazy && isEmpty(props.options)) {\n        initialLoaded.value = false\n        lazyLoad(undefined, (list) => {\n          if (list) {\n            store = new Store(list, cfg)\n            menus.value = [store.getNodes()]\n          }\n          initialLoaded.value = true\n          syncCheckedValue(false, true)\n        })\n      } else {\n        syncCheckedValue(false, true)\n      }\n    }\n\n    const lazyLoad: ElCascaderPanelContext['lazyLoad'] = (node, cb) => {\n      const cfg = config.value\n      node! = node || new Node({}, cfg, undefined, true)\n      node.loading = true\n\n      const resolve = (dataList: CascaderOption[]) => {\n        const _node = node as Node\n        const parent = _node.root ? null : _node\n        dataList && store?.appendNodes(dataList, parent as any)\n        _node.loading = false\n        _node.loaded = true\n        _node.childrenData = _node.childrenData || []\n        cb && cb(dataList)\n      }\n\n      cfg.lazyLoad(node, resolve as any)\n    }\n\n    const expandNode: ElCascaderPanelContext['expandNode'] = (node, silent) => {\n      const { level } = node\n      const newMenus = menus.value.slice(0, level)\n      let newExpandingNode: Nullable<CascaderNode>\n\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2]\n      } else {\n        newExpandingNode = node\n        newMenus.push(node.children)\n      }\n\n      if (expandingNode.value?.uid !== newExpandingNode?.uid) {\n        expandingNode.value = node\n        menus.value = newMenus\n        !silent && emit('expand-change', node?.pathValues || [])\n      }\n    }\n\n    const handleCheckChange: ElCascaderPanelContext['handleCheckChange'] = (\n      node,\n      checked,\n      emitClose = true\n    ) => {\n      const { checkStrictly, multiple } = config.value\n      const oldNode = checkedNodes.value[0]\n      manualChecked = true\n\n      !multiple && oldNode?.doCheck(false)\n      node.doCheck(checked)\n      calculateCheckedValue()\n      emitClose && !multiple && !checkStrictly && emit('close')\n      !emitClose && !multiple && !checkStrictly && expandParentNode(node)\n    }\n\n    const expandParentNode = (node) => {\n      if (!node) return\n      node = node.parent\n      expandParentNode(node)\n      node && expandNode(node)\n    }\n\n    const getFlattedNodes = (leafOnly: boolean) => {\n      return store?.getFlattedNodes(leafOnly)\n    }\n\n    const getCheckedNodes = (leafOnly: boolean) => {\n      return getFlattedNodes(leafOnly)?.filter((node) => node.checked !== false)\n    }\n\n    const clearCheckedNodes = () => {\n      checkedNodes.value.forEach((node) => node.doCheck(false))\n      calculateCheckedValue()\n    }\n\n    const calculateCheckedValue = () => {\n      const { checkStrictly, multiple } = config.value\n      const oldNodes = checkedNodes.value\n      const newNodes = getCheckedNodes(!checkStrictly)!\n      // ensure the original order\n      const nodes = sortByOriginalOrder(oldNodes, newNodes)\n      const values = nodes.map((node) => node.valueByOption)\n      checkedNodes.value = nodes\n      checkedValue.value = multiple ? values : values[0] ?? null\n    }\n\n    const syncCheckedValue = (loaded = false, forced = false) => {\n      const { modelValue } = props\n      const { lazy, multiple, checkStrictly } = config.value\n      const leafOnly = !checkStrictly\n\n      if (\n        !initialLoaded.value ||\n        manualChecked ||\n        (!forced && isEqual(modelValue, checkedValue.value))\n      )\n        return\n\n      if (lazy && !loaded) {\n        const values: CascaderNodeValue[] = unique(\n          flattenDeep(castArray(modelValue))\n        )\n        const nodes = values\n          .map((val) => store?.getNodeByValue(val))\n          .filter((node) => !!node && !node.loaded && !node.loading) as Node[]\n\n        if (nodes.length) {\n          nodes.forEach((node) => {\n            lazyLoad(node, () => syncCheckedValue(false, forced))\n          })\n        } else {\n          syncCheckedValue(true, forced)\n        }\n      } else {\n        const values = multiple ? castArray(modelValue) : [modelValue]\n        const nodes = unique(\n          values.map((val) => store?.getNodeByValue(val, leafOnly))\n        ) as Node[]\n        syncMenuState(nodes, forced)\n        checkedValue.value = modelValue!\n      }\n    }\n\n    const syncMenuState = (\n      newCheckedNodes: CascaderNode[],\n      reserveExpandingState = true\n    ) => {\n      const { checkStrictly } = config.value\n      const oldNodes = checkedNodes.value\n      const newNodes = newCheckedNodes.filter(\n        (node) => !!node && (checkStrictly || node.isLeaf)\n      )\n      const oldExpandingNode = store?.getSameNode(expandingNode.value!)\n      const newExpandingNode =\n        (reserveExpandingState && oldExpandingNode) || newNodes[0]\n\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach((node) => expandNode(node, true))\n      } else {\n        expandingNode.value = null\n      }\n\n      oldNodes.forEach((node) => node.doCheck(false))\n      newNodes.forEach((node) => node.doCheck(true))\n\n      checkedNodes.value = newNodes\n      nextTick(scrollToExpandingNode)\n    }\n\n    const scrollToExpandingNode = () => {\n      if (!isClient) return\n\n      menuList.value.forEach((menu) => {\n        const menuElement = menu?.$el\n        if (menuElement) {\n          const container = menuElement.querySelector(\n            `.${ns.namespace.value}-scrollbar__wrap`\n          )\n          const activeNode =\n            menuElement.querySelector(`.${ns.b('node')}.${ns.is('active')}`) ||\n            menuElement.querySelector(`.${ns.b('node')}.in-active-path`)\n          scrollIntoView(container, activeNode)\n        }\n      })\n    }\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const target = e.target as HTMLElement\n      const { code } = e\n\n      switch (code) {\n        case EVENT_CODE.up:\n        case EVENT_CODE.down: {\n          e.preventDefault()\n          const distance = code === EVENT_CODE.up ? -1 : 1\n          focusNode(\n            getSibling(target, distance, `.${ns.b('node')}[tabindex=\"-1\"]`)\n          )\n          break\n        }\n        case EVENT_CODE.left: {\n          e.preventDefault()\n          const preMenu = menuList.value[getMenuIndex(target) - 1]\n          const expandedNode = preMenu?.$el.querySelector(\n            `.${ns.b('node')}[aria-expanded=\"true\"]`\n          )\n          focusNode(expandedNode)\n          break\n        }\n        case EVENT_CODE.right: {\n          e.preventDefault()\n          const nextMenu = menuList.value[getMenuIndex(target) + 1]\n          const firstNode = nextMenu?.$el.querySelector(\n            `.${ns.b('node')}[tabindex=\"-1\"]`\n          )\n          focusNode(firstNode)\n          break\n        }\n        case EVENT_CODE.enter:\n          checkNode(target)\n          break\n      }\n    }\n\n    provide(\n      CASCADER_PANEL_INJECTION_KEY,\n      reactive({\n        config,\n        expandingNode,\n        checkedNodes,\n        isHoverMenu,\n        initialLoaded,\n        renderLabelFn,\n        lazyLoad,\n        expandNode,\n        handleCheckChange,\n      })\n    )\n\n    watch([config, () => props.options], initStore, {\n      deep: true,\n      immediate: true,\n    })\n\n    watch(\n      () => props.modelValue,\n      () => {\n        manualChecked = false\n        syncCheckedValue()\n      }\n    )\n\n    watch(checkedValue, (val) => {\n      if (!isEqual(val, props.modelValue)) {\n        emit(UPDATE_MODEL_EVENT, val)\n        emit(CHANGE_EVENT, val)\n      }\n    })\n\n    onBeforeUpdate(() => (menuList.value = []))\n\n    onMounted(() => !isEmpty(props.modelValue) && syncCheckedValue())\n\n    return {\n      ns,\n      menuList,\n      menus,\n      checkedNodes,\n      handleKeyDown,\n      handleCheckChange,\n      getFlattedNodes,\n      getCheckedNodes,\n      clearCheckedNodes,\n      calculateCheckedValue,\n      scrollToExpandingNode,\n    }\n  },\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}